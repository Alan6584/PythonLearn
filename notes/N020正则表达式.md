###正则表达式

字符串是编程时涉及到的最多的一种数据结构，对字符串进行操作的需求几乎无处不在。比如判断一个字符串是否是合法的Email地址，虽然可以编程提取`@`前后的子串，再分别判断是否是单词和域名，但这样做不但麻烦，而且代码难以复用。

正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。

所以我们判断一个字符串是否是合法的Email的方法是：

1. 创建一个匹配Email的正则表达式；
2. 用该正则表达式去匹配用户的输入来判断是否合法。

因为正则表达式也是用字符串表示的，所以，我们要首先了解如何用字符来描述字符。

在正则表达式中，如果直接给出字符，就是精确匹配。用`\d`可以匹配一个数字，`\w`可以匹配一个字母或数字，所以：

- `'00\d'`可以匹配`'007'`，但无法匹配`'00A'`；
- `'\d\d\d'`可以匹配`'010'`；
- `'\w\w\d'`可以匹配`'py3'`；

`.`可以匹配任意字符，所以：

- `'py.'`可以匹配`'pyc'`、`'pyo'`、`'py!'`等等。

要匹配变长的字符，在正则表达式中，用`*`表示任意个字符（包括0个），用`+`表示至少一个字符，用`?`表示0个或1个字符，用`{n}`表示n个字符，用`{n,m}`表示n-m个字符：

来看一个复杂的例子：`\d{3}\s+\d{3,8}`。

我们来从左到右解读一下：

1. `\d{3}`表示匹配3个数字，例如`'010'`；
2. `\s`可以匹配一个空格（也包括Tab等空白符），所以`\s+`表示至少有一个空格，例如匹配`' '`，`' '`等；
3. `\d{3,8}`表示3-8个数字，例如`'1234567'`。

综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。

如果要匹配`'010-12345'`这样的号码呢？由于`'-'`是特殊字符，在正则表达式中，要用`'\'`转义，所以，上面的正则是`\d{3}\-\d{3,8}`。

但是，仍然无法匹配`'010 - 12345'`，因为带有空格。所以我们需要更复杂的匹配方式。

### 进阶

要做更精确地匹配，可以用`[]`表示范围，比如：

- `[0-9a-zA-Z\_]`可以匹配一个数字、字母或者下划线；
- `[0-9a-zA-Z\_]+`可以匹配至少由一个数字、字母或者下划线组成的字符串，比如`'a100'`，`'0_Z'`，`'Py3000'`等等；
- `[a-zA-Z\_][0-9a-zA-Z\_]*`可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；
- `[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}`更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。

`A|B`可以匹配A或B，所以`(P|p)ython`可以匹配`'Python'`或者`'python'`。

`^`表示行的开头，`^\d`表示必须以数字开头。

`$`表示行的结束，`\d$`表示必须以数字结束。

你可能注意到了，`py`也可以匹配`'python'`，但是加上`^py$`就变成了整行匹配，就只能匹配`'py'`了。



有了准备知识，我们就可以在Python中使用正则表达式了。Python提供`re`模块，包含所有正则表达式的功能。由于Python的字符串本身也用`\`转义，所以要特别注意：

```
s = 'ABC\\-001' # Python的字符串
# 对应的正则表达式字符串变成：
# 'ABC\-001'

```

因此我们强烈建议使用Python的`r`前缀，就不用考虑转义的问题了：

```
s = r'ABC\-001' # Python的字符串
# 对应的正则表达式字符串不变：
# 'ABC\-001'

```

先看看如何判断正则表达式是否匹配：

```python
>>> import re
>>> re.match(r'^\d{3}\-\d{3,8}$', '010-12345')
<_sre.SRE_Match object at 0x1026e18b8>
>>> re.match(r'^\d{3}\-\d{3,8}$', '010 12345')
>>>
```

Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。

re 模块使 Python 语言拥有全部的正则表达式功能。

compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。

re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。

本章节主要介绍Python中常用的正则表达式处理函数。



####re.match函数

re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。

**函数语法**：

```
re.match(pattern, string, flags=0)
```

函数参数说明：

| 参数      | 描述                                   |
| ------- | ------------------------------------ |
| pattern | 匹配的正则表达式                             |
| string  | 要匹配的字符串。                             |
| flags   | 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 |

匹配成功re.match方法返回一个匹配的对象，否则返回None。

我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。

| 匹配对象方法       | 描述                                       |
| ------------ | ---------------------------------------- |
| group(num=0) | 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 |
| groups()     | 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。           |

#####实例 1

```python
#!/usr/bin/python
# -*- coding: UTF-8 -*- 
 
import re
print(re.match('www', 'www.runoob.com').span())  # 在起始位置匹配
print(re.match('com', 'www.runoob.com'))         # 不在起始位置匹配
```

以上实例运行输出结果为：

```
(0, 3)
None
```

#####实例 2

```python
#!/usr/bin/python
import re
 
line = "Cats are smarter than dogs"
 
matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I)
 
if matchObj:
   print "matchObj.group() : ", matchObj.group()
   print "matchObj.group(1) : ", matchObj.group(1)
   print "matchObj.group(2) : ", matchObj.group(2)
else:
   print "No match!!"
```

以上实例执行结果如下：

```
matchObj.group() :  Cats are smarter than dogs
matchObj.group(1) :  Cats
matchObj.group(2) :  smarter
```

正则表达式：

```
r'(.*) are (.*?) .*'
```

#####解析:

首先，这是一个字符串，前面的一个 r 表示字符串为非转义的原始字符串，让编译器忽略反斜杠，也就是忽略转义字符。但是这个字符串里没有反斜杠，所以这个 r 可有可无。

- **(.\*)** 第一个匹配分组，.* 代表匹配除换行符之外的所有字符。
- **(.\*?)** 第二个匹配分组，.*? 后面多个问号，代表非贪婪模式，也就是说只匹配符合条件的最少字符
- 后面的一个 .* 没有括号包围，所以不是分组，匹配效果和第一个一样，但是不计入匹配结果中。

matchObj.group() 等同于 matchObj.group(0)，表示匹配到的完整文本字符

matchObj.group(1) 得到第一组匹配结果，也就是(.*)匹配到的

matchObj.group(2) 得到第二组匹配结果，也就是(.*?)匹配到的

因为只有匹配结果中只有两组，所以如果填 3 时会报错。

####re.search方法

re.search 扫描整个字符串并返回第一个成功的匹配。

函数语法：

```
re.search(pattern, string, flags=0)
```

函数参数说明：

| 参数      | 描述                                   |
| ------- | ------------------------------------ |
| pattern | 匹配的正则表达式                             |
| string  | 要匹配的字符串。                             |
| flags   | 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 |

匹配成功re.search方法返回一个匹配的对象，否则返回None。

我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。

| 匹配对象方法       | 描述                                       |
| ------------ | ---------------------------------------- |
| group(num=0) | 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 |
| groups()     | 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。           |

#####实例 1

```python
#!/usr/bin/python
# -*- coding: UTF-8 -*- 
 
import re
print(re.search('www', 'www.runoob.com').span())  # 在起始位置匹配
print(re.search('com', 'www.runoob.com').span())         # 不在起始位置匹配
```

以上实例运行输出结果为：

```
(0, 3)
(11, 14)
```

####实例 2

```python
#!/usr/bin/python
import re
 
line = "Cats are smarter than dogs";
 
searchObj = re.search( r'(.*) are (.*?) .*', line, re.M|re.I)
 
if searchObj:
   print "searchObj.group() : ", searchObj.group()
   print "searchObj.group(1) : ", searchObj.group(1)
   print "searchObj.group(2) : ", searchObj.group(2)
else:
   print "Nothing found!!"
```

以上实例执行结果如下：

```
searchObj.group() :  Cats are smarter than dogs
searchObj.group(1) :  Cats
searchObj.group(2) :  smarter
```

####re.match与re.search的区别

re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。

#####实例

```python
#!/usr/bin/python
import re
 
line = "Cats are smarter than dogs";
 
matchObj = re.match( r'dogs', line, re.M|re.I)
if matchObj:
   print "match --> matchObj.group() : ", matchObj.group()
else:
   print "No match!!"
 
matchObj = re.search( r'dogs', line, re.M|re.I)
if matchObj:
   print "search --> matchObj.group() : ", matchObj.group()
else:
   print "No match!!"
```

以上实例执行结果：

```
No match!!
search --> matchObj.group() :  dogs
```

####检索和替换

Python 的 re 模块提供了re.sub用于替换字符串中的匹配项。

语法：

```
re.sub(pattern, repl, string, count=0, flags=0)
```

参数：

- pattern : 正则中的模式字符串。
- repl : 替换的字符串，也可为一个函数。
- string : 要被查找替换的原始字符串。
- count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。

#####实例

```python
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
import re
 
phone = "2004-959-559 # 这是一个国外电话号码"
 
# 删除字符串中的 Python注释 
num = re.sub(r'#.*$', "", phone)
print "电话号码是: ", num
 
# 删除非数字(-)的字符串 
num = re.sub(r'\D', "", phone)
print "电话号码是 : ", num
```

以上实例执行结果：

```
电话号码是:  2004-959-559 
电话号码是 :  2004959559
```

####repl 参数是一个函数

以下实例中将字符串中的匹配的数字乘于 2：

#####实例

```python
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
import re
 
# 将匹配的数字乘于 2
def double(matched):
    value = int(matched.group('value'))
    return str(value * 2)
 
s = 'A23G4HFD567'
print(re.sub('(?P<value>\d+)', double, s))
```

执行输出结果为：

```
A46G8HFD1134
```

####正则表达式修饰符 - 可选标志

正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：

| 修饰符  | 描述                                      |
| ---- | --------------------------------------- |
| re.I | 使匹配对大小写不敏感                              |
| re.L | 做本地化识别（locale-aware）匹配                  |
| re.M | 多行匹配，影响 ^ 和 $                           |
| re.S | 使 . 匹配包括换行在内的所有字符                       |
| re.U | 根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B. |
| re.X | 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。         |

####正则表达式模式

模式字符串使用特殊的语法来表示一个正则表达式：

字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。

多数字母和数字前加一个反斜杠时会拥有不同的含义。

标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。

反斜杠本身需要使用反斜杠转义。

由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r'\t'，等价于 '\\t')匹配相应的特殊字符。

下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。

| 模式          | 描述                                       |
| ----------- | ---------------------------------------- |
| ^           | 匹配字符串的开头                                 |
| $           | 匹配字符串的末尾。                                |
| .           | 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 |
| [...]       | 用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'       |
| [^...]      | 不在[]中的字符：\[^abc\] 匹配除了a,b,c之外的字符。        |
| re*         | 匹配0个或多个的表达式。                             |
| re+         | 匹配1个或多个的表达式。                             |
| re?         | 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式              |
| re{ n}      |                                          |
| re{ n,}     | 精确匹配n个前面表达式。                             |
| re{ n, m}   | 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式            |
| a\| b       | 匹配a或b                                    |
| (re)        | G匹配括号内的表达式，也表示一个组                        |
| (?imx)      | 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。      |
| (?-imx)     | 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。        |
| (?: re)     | 类似 (...), 但是不表示一个组                       |
| (?imx: re)  | 在括号中使用i, m, 或 x 可选标志                     |
| (?-imx: re) | 在括号中不使用i, m, 或 x 可选标志                    |
| (?#...)     | 注释.                                      |
| (?= re)     | 前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 |
| (?! re)     | 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功   |
| (?> re)     | 匹配的独立模式，省去回溯。                            |
| \w          | 匹配字母数字及下划线                               |
| \W          | 匹配非字母数字及下划线                              |
| \s          | 匹配任意空白字符，等价于 [\t\n\r\f].                 |
| \S          | 匹配任意非空字符                                 |
| \d          | 匹配任意数字，等价于 [0-9].                        |
| \D          | 匹配任意非数字                                  |
| \A          | 匹配字符串开始                                  |
| \Z          | 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。c          |
| \z          | 匹配字符串结束                                  |
| \G          | 匹配最后匹配完成的位置。                             |
| \b          | 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。 |
| \B          | 匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。 |
| \n, \t, 等.  | 匹配一个换行符。匹配一个制表符。等                        |
| \1...\9     | 匹配第n个分组的内容。                              |
| \10         | 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。       |

####正则表达式实例

#####字符匹配

| 实例     | 描述           |
| ------ | ------------ |
| python | 匹配 "python". |

#####字符类

| 实例          | 描述                      |
| ----------- | ----------------------- |
| [Pp]ython   | 匹配 "Python" 或 "python"  |
| rub[ye]     | 匹配 "ruby" 或 "rube"      |
| [aeiou]     | 匹配中括号内的任意一个字母           |
| [0-9]       | 匹配任何数字。类似于 [0123456789] |
| [a-z]       | 匹配任何小写字母                |
| [A-Z]       | 匹配任何大写字母                |
| [a-zA-Z0-9] | 匹配任何字母及数字               |
| [^aeiou]    | 除了aeiou字母以外的所有字符        |
| [^0-9]      | 匹配除了数字外的字符              |

#####特殊字符类

| 实例   | 描述                                       |
| ---- | ---------------------------------------- |
| .    | 匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用象 '[.\n]' 的模式。 |
| \d   | 匹配一个数字字符。等价于 [0-9]。                      |
| \D   | 匹配一个非数字字符。等价于 \[^0-9\]。                  |
| \s   | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 |
| \S   | 匹配任何非空白字符。等价于 \[^ \f\n\r\t\v\]。          |
| \w   | 匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。        |
| \W   | 匹配任何非单词字符。等价于 '\[^A-Za-z0-9_\]'。         |



###常用正则表达式—邮箱（Email）

 本文针对有一点正则基础的同学，如果你对正则一无所知，请移步“[正则表达式30分钟入门教程](http://deerchao.net/tutorials/regex/regex.htm)”学习。

 要验证一个字符串是否为邮箱的话，首先要了解邮箱账号的格式。我尝试过在网上找出一个标准的格式，但是很遗憾我没有找到。我也尝试使用RFC标准来判断邮箱的格式，但是也没有结果。网上些博客说不应该使用RFC标准来验证邮箱是否合法，有兴趣的可以看看“[is this email valid?](http://isemail.info/about)”和“[Don’t RFC-Validate Email Addresses](http://girders.org/blog/2013/01/31/dont-rfc-validate-email-addresses/)”。据了解【[参考](http://sztqb.sznews.com/html/2008-10/07/content_359513.htm)】，现在用中文命名的邮箱也合法了，比如“杨元庆＠联想.中国”。

 虽然没有统一的邮箱账号格式，但是所有邮箱都符合“名称@域名”的规律。对于名称和域名的字符限制，我们可以根据项目的情况定义一个，比如只允许有英文、数字、下划线等组成。下面举例实现一些验证邮箱格式的正则表达式。 



####实例1:只允许英文字母、数字、下划线、英文句号、以及中划线组成

**举例：zhangsan-001@gmail.com** 
**分析邮件名称部分：**

- 26个大小写英文字母表示为`a-zA-Z`
- 数字表示为`0-9`
- 下划线表示为`_`
- 中划线表示为`-`
- 由于名称是由若干个字母、数字、下划线和中划线组成，所以需要用到`+`表示多次出现

 根据以上条件得出邮件名称表达式：`[a-zA-Z0-9_-]+` 
**分析域名部分：**

 一般域名的规律为“[N级域名][三级域名.]二级域名.顶级域名”，比如“qq.com”、“www.qq.com”、“mp.weixin.qq.com”、“12-34.com.cn”，分析可得域名类似“`**` `.**``.**` `.**`”组成。

- “**”部分可以表示为`[a-zA-Z0-9_-]+`
- “.**”部分可以表示为`\.[a-zA-Z0-9_-]+`
- 多个“.**”可以表示为`(\.[a-zA-Z0-9_-]+)+`

 综上所述，域名部分可以表示为`[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+`

**最终表达式：** 
 由于邮箱的基本格式为“名称@域名”，需要使用“^”匹配邮箱的开始部分，用“$”匹配邮箱结束部分以保证邮箱前后不能有其他字符，所以最终邮箱的正则表达式为： 
  `^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$`



####实例2、名称允许汉字、字母、数字，域名只允许英文域名

**举例：杨元庆001Abc@lenovo.com.cn**

**分析邮件名称部分：**

- 汉字在正则表示为`[\u4e00-\u9fa5]`
- 字母和数字表示为`A-Za-z0-9` 
   通过分析得出邮件名称部分表达式为`[A-Za-z0-9\u4e00-\u9fa5]+`

**分析邮件域名部分**

 邮件部分可以参考`实例1`中的`分析域名部分`。 
 得出域名部分的表达式为`[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+`。

**最终表达式：** 
 我们用@符号将邮箱的名称和域名拼接起来，因此完整的邮箱表达式为 
  `^[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$`